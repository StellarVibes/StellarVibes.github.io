[{"content":"正文 介绍常用基础算法\n1. 快速排序 确定分界点 调整 \u0026lt;x 左边 x \u0026gt;x 右边 递归排序 1 2 3 4 5 6 7 8 9 10 11 12 13 void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int x = q[l], i = l - 1, j = r + 1; while (i \u0026lt; j) { do i++; while (q[i] \u0026lt; x); do j--; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } 2.归并排序 1 2 3 4 时间复杂度：n*logN logN 层 每层 n 次 确定分界点 mid = （l+r）/2 递归排序 归并 合二为一 两个数组分别用 tmp1 tmp2 下标进行比较 形成有序的新数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int tmp[100010]; // 假设数组长度不超过 1e5 int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while (i \u0026lt;= mid) tmp[k++] = q[i++]; while (j \u0026lt;= r) tmp[k++] = q[j++]; for (i = l, j = 0; i \u0026lt;= r; i++, j++) q[i] = tmp[j]; } 3.二分排序 有单调性一定可以二分 没有单调性也可能可以二分 int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 4.高精度 数据逆向存储 1） 加法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // C = A + B，A、B为非负整数，按低位到高位存储 vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B) { vector\u0026lt;int\u0026gt; C; int t = 0; // 进位 for (int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size() || t; ++i) { if (i \u0026lt; A.size()) t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); // 当前位 t /= 10; // 新的进位 } return C; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // C = A + B，A、B为非负整数，按低位到高位存储 vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B) { vector\u0026lt;int\u0026gt; C; if (A.size() \u0026lt; B.size()) return add(B, A); // 保证 A 较长 int t = 0; // 进位 for (int i = 0; i \u0026lt; A.size(); ++i) { t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); // 当前位 t /= 10; // 新的进位 } if (t) C.push_back(t); // 处理最高位进位 return C; } 2） 减法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 判断 A \u0026gt;= B bool cmp(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B) { if (A.size() != B.size()) return A.size() \u0026gt; B.size(); for (int i = A.size() - 1; i \u0026gt;= 0; --i) if (A[i] != B[i]) return A[i] \u0026gt; B[i]; return true; // 完全相等 } // C = A - B，调用前需保证 A \u0026gt;= B vector\u0026lt;int\u0026gt; sub(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B) { vector\u0026lt;int\u0026gt; C; int t = 0; // 借位 for (int i = 0; i \u0026lt; A.size(); ++i) { t = A[i] - t; if (i \u0026lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); // 保证本位非负 if (t \u0026lt; 0) t = 1; // 需要借位 else t = 0; } while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); // 去掉前导 0 return C; } 3） 乘法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // C = A * b，A 为高精度（低位在前），b 为 int vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt;\u0026amp; A, int b) { vector\u0026lt;int\u0026gt; C; int t = 0; // 进位 for (int i = 0; i \u0026lt; A.size() || t; ++i) { if (i \u0026lt; A.size()) t += A[i] * b; C.push_back(t % 10); // 当前位 t /= 10; // 新的进位 } while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); // 去前导 0 return C; } 4） 除法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // C = A / b，r 返回余数（A 高位在前，C 低位在前） vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt;\u0026amp; A, int b, int\u0026amp; r) { vector\u0026lt;int\u0026gt; C; r = 0; for (int i = 0; i \u0026lt; A.size(); ++i) { // 从高位到低位 r = r * 10 + A[i]; C.push_back(r / b); r %= b; } // 把结果改成低位在前，去掉前导 0 reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 5.前缀和与差分 1）前缀和 1 2 3 sum[i]=sum[i-1]+nums[i] （ sum[0]=0 ） for (int i = 1; i \u0026lt;= n; ++i) s[i] = s[i - 1] + a[i]; 2）二维前缀和 1 2 sum[x1][y1]=sum[x1-1][y1]+sum[x1][y1-1]-sum[x1-1][y1-1]+nums[x1][y1] s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; 1 2 任一区域=sum[x1][y1]-sum[x2][y1]-sum[x1][y2]+sum[x2][y2] s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; 3） 差分（前缀和的逆运算） 1 2 3 4 5 a1 = b1 b1 = a1 a2 = b1 + b2 b2 = a2-a1 a3 = b1 + b2 +b3\tb3 = a3-a2 An = B1+....+Bn A 为 B 的前缀和 B 为 A 的差分 O（n） B --\u0026gt; A 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } for (int i = 1; i \u0026lt;= n; i ++) insert(i, i, a[i]); while (m--) { int l, r, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;c); insert(l, r, c); } 4） 二维差分 1 2 3 4 5 6 void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } 1 2 3 4 5 6 7 8 9 10 while (q--) { int x1, y1, x2, y2, c; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2 \u0026gt;\u0026gt; c; insert(x1, y1, x2, y2, c); } for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; 6.双指针算法 核心是优化 1 2 3 4 5 6 7 8 for (int i = 0, j = 0; i \u0026lt; n; i++) { s[a[i]]++; while (s[a[i]] \u0026gt; 1) { s[a[j]]--; j++; } res = max(res, i - j + 1); } 7.位运算 (n \u0026gt;\u0026gt; k \u0026amp; 1) // 取 n 的第 k 位 1 2 3 4 5 lowbit(x) 返回 x 的最后一位 1 x = 1010````1000 ~x = 0101````0111 ~x +1 = 0101````1000 x\u0026amp;(~x +1) = 0000````1000 1 2 3 4 5 6 7 8 9 10 int lowbit(int x) // 返回 x 的最后一位 1 { return x \u0026amp; -x; } while (x) // 每次减去 x 的最后一位 1 { x -= lowbit(x); res++; } 8.离散化 对分散数据进行映射存储 1 2 3 4 5 6 7 8 9 vector\u0026lt;int\u0026gt;::iterator unique(vector\u0026lt;int\u0026gt; \u0026amp;a) { int j = 0; for (int i = 0; i \u0026lt; a.size(); i++) if (!i || a[i] != a[i - 1]) a[j++] = a[i]; // a[0] ~ a[j - 1] 保存 a 中所有不重复的数 return a.begin() + j; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 vector\u0026lt;int\u0026gt; alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出 x 对应的离散化的值 int find(int x) // 找到第一个大于等于 x 的位置 { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; // 映射到 1, 2, ... n } 9.区间合并 1） 按区间左端点排序 2）三种区间 1 2 3 包含 省略 相交 扩充成两个区间的交集 无交集 保存 更新成下一个区间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 将所有存在交集的区间合并 void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) { if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else { ed = max(ed, seg.second); } } if (st != -2e9) res.push_back({st, ed}); segs = res; } ","date":"2025-10-21T00:00:00Z","image":"https://StellarVibes.github.io/p/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/1_hu_cf061daa3c7e9e51.png","permalink":"https://StellarVibes.github.io/p/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","title":"基础算法"},{"content":"正文 翻到两年杂乱的 Gitee 提交的代码，有c/c++/python/matlab/python/css/js/html，不同平台的算法题和看到语雀里堆在一起的笔记和csdn的几十篇博客，我想用这个网站复盘自己 “放养” 知识和合理存放代码的问题，一起加油吧！ 附上gitee提交记录和csdn博客： 链接 Gitee 主页 🍁 CSDN 博客ᯤ⁶ᴳ⁺⁵²⁰ ⌯˃̶ᗜ˂̶⌯ಣ\n","date":"2025-10-16T00:00:00Z","image":"https://StellarVibes.github.io/p/test-chinese/1_hu_dba4dc0722038740.png","permalink":"https://StellarVibes.github.io/p/test-chinese/","title":"初心"}]